<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jithub: include/dataStructs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jithub
   &#160;<span id="projectnumber">R2</span>
   </div>
   <div id="projectbrief">ProgrammersGuideforModuleR2forCS450.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dataStructs.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structures associated with processes and the functions to go with them.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;memory.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for dataStructs.h:</div>
<div class="dyncontent">
<div class="center"><img src="dataStructs_8h__incl.png" border="0" usemap="#include_2dataStructs_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="dataStructs_8h__dep__incl.png" border="0" usemap="#include_2dataStructs_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="dataStructs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcb.html">pcb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqueue.html">queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8350cd7e7067eae14cdb160dac06f8e6"><td class="memItemLeft" align="right" valign="top"><a id="a8350cd7e7067eae14cdb160dac06f8e6"></a>
typedef struct <a class="el" href="structpcb.html">pcb</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pcb</b></td></tr>
<tr class="separator:a8350cd7e7067eae14cdb160dac06f8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092902733e164e20a40f08447ef1705a"><td class="memItemLeft" align="right" valign="top"><a id="a092902733e164e20a40f08447ef1705a"></a>
typedef struct <a class="el" href="structqueue.html">queue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>queue</b></td></tr>
<tr class="separator:a092902733e164e20a40f08447ef1705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b7d58425f0a1c747ab3825128ad255e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a6b7d58425f0a1c747ab3825128ad255e">enqueue</a> (<a class="el" href="structqueue.html">queue</a> *q, <a class="el" href="structpcb.html">pcb</a> *newPCB)</td></tr>
<tr class="memdesc:a6b7d58425f0a1c747ab3825128ad255e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new PCB to the queue.  <a href="dataStructs_8h.html#a6b7d58425f0a1c747ab3825128ad255e">More...</a><br /></td></tr>
<tr class="separator:a6b7d58425f0a1c747ab3825128ad255e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64624cc8e7f9299be0b63303c460cf4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcb.html">pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a64624cc8e7f9299be0b63303c460cf4f">dequeue</a> (<a class="el" href="structqueue.html">queue</a> *q)</td></tr>
<tr class="memdesc:a64624cc8e7f9299be0b63303c460cf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pcb from the front of the queue.  <a href="dataStructs_8h.html#a64624cc8e7f9299be0b63303c460cf4f">More...</a><br /></td></tr>
<tr class="separator:a64624cc8e7f9299be0b63303c460cf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c35e290b62ef30ae01cebd25556715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#ae8c35e290b62ef30ae01cebd25556715">printq</a> (<a class="el" href="structqueue.html">queue</a> *q)</td></tr>
<tr class="memdesc:ae8c35e290b62ef30ae01cebd25556715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the queue.  <a href="dataStructs_8h.html#ae8c35e290b62ef30ae01cebd25556715">More...</a><br /></td></tr>
<tr class="separator:ae8c35e290b62ef30ae01cebd25556715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c16934c9d95f3583cf09891d18c095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcb.html">pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a63c16934c9d95f3583cf09891d18c095">pcb_allocate</a> (void)</td></tr>
<tr class="memdesc:a63c16934c9d95f3583cf09891d18c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a PCB.  <a href="dataStructs_8h.html#a63c16934c9d95f3583cf09891d18c095">More...</a><br /></td></tr>
<tr class="separator:a63c16934c9d95f3583cf09891d18c095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1169eb5fd9b017a90dcbf1f29df686d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a1169eb5fd9b017a90dcbf1f29df686d7">pcb_free</a> (<a class="el" href="structpcb.html">pcb</a> *<a class="el" href="structpcb.html">pcb</a>)</td></tr>
<tr class="memdesc:a1169eb5fd9b017a90dcbf1f29df686d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocates the memory associated with a PCB  <a href="dataStructs_8h.html#a1169eb5fd9b017a90dcbf1f29df686d7">More...</a><br /></td></tr>
<tr class="separator:a1169eb5fd9b017a90dcbf1f29df686d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ca7260fdc87d4c04b5689c566fcea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcb.html">pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a90ca7260fdc87d4c04b5689c566fcea0">pcb_setup</a> (const char *name, int clas, int priority)</td></tr>
<tr class="memdesc:a90ca7260fdc87d4c04b5689c566fcea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new PCB.  <a href="dataStructs_8h.html#a90ca7260fdc87d4c04b5689c566fcea0">More...</a><br /></td></tr>
<tr class="separator:a90ca7260fdc87d4c04b5689c566fcea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a28272eee57e85fc44b9045f0f0f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcb.html">pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a32a28272eee57e85fc44b9045f0f0f6e">pcb_find</a> (<a class="el" href="structqueue.html">queue</a> *ready, <a class="el" href="structqueue.html">queue</a> *blocked, <a class="el" href="structqueue.html">queue</a> *susReady, <a class="el" href="structqueue.html">queue</a> *susBlocked, const char *name)</td></tr>
<tr class="memdesc:a32a28272eee57e85fc44b9045f0f0f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a name, returns a pointer to the PCB.  <a href="dataStructs_8h.html#a32a28272eee57e85fc44b9045f0f0f6e">More...</a><br /></td></tr>
<tr class="separator:a32a28272eee57e85fc44b9045f0f0f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af356fb7356e23ff1064529fb317d52eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#af356fb7356e23ff1064529fb317d52eb">pcb_insert</a> (<a class="el" href="structqueue.html">queue</a> *ready, <a class="el" href="structqueue.html">queue</a> *blocked, <a class="el" href="structqueue.html">queue</a> *susReady, <a class="el" href="structqueue.html">queue</a> *susBlocked, <a class="el" href="structpcb.html">pcb</a> *<a class="el" href="structpcb.html">pcb</a>)</td></tr>
<tr class="memdesc:af356fb7356e23ff1064529fb317d52eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a PCB into the proper queue.  <a href="dataStructs_8h.html#af356fb7356e23ff1064529fb317d52eb">More...</a><br /></td></tr>
<tr class="separator:af356fb7356e23ff1064529fb317d52eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688d95412aca3fe3fdfbe4018f71a407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataStructs_8h.html#a688d95412aca3fe3fdfbe4018f71a407">pcb_remove</a> (<a class="el" href="structqueue.html">queue</a> *ready, <a class="el" href="structqueue.html">queue</a> *blocked, <a class="el" href="structqueue.html">queue</a> *susReady, <a class="el" href="structqueue.html">queue</a> *susBlocked, <a class="el" href="structpcb.html">pcb</a> *<a class="el" href="structpcb.html">pcb</a>)</td></tr>
<tr class="memdesc:a688d95412aca3fe3fdfbe4018f71a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a PCB.  <a href="dataStructs_8h.html#a688d95412aca3fe3fdfbe4018f71a407">More...</a><br /></td></tr>
<tr class="separator:a688d95412aca3fe3fdfbe4018f71a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structures associated with processes and the functions to go with them. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a64624cc8e7f9299be0b63303c460cf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64624cc8e7f9299be0b63303c460cf4f">&#9670;&nbsp;</a></span>dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcb.html">pcb</a>* dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a pcb from the front of the queue. </p>
<dl class="section author"><dt>Author</dt><dd>Samesh Desai </dd>
<dd>
Noah Marner </dd>
<dd>
Jackson Monk </dd>
<dd>
Blake Wagner </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the removed PCB</dd></dl>
<p>Checks if the queue is empty (Head is NULL). Creates a temp pcb to point to the head. If heads next exists, set head to point to head next and returns the temp pcb which points to the old head. Otherwise the queue only has 1 item so the head and tail are set to NULL and we return temp </p>

</div>
</div>
<a id="a6b7d58425f0a1c747ab3825128ad255e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7d58425f0a1c747ab3825128ad255e">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcb.html">pcb</a> *&#160;</td>
          <td class="paramname"><em>newPCB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new PCB to the queue. </p>
<dl class="section author"><dt>Author</dt><dd>Samesh Desai </dd>
<dd>
Noah Marner </dd>
<dd>
Jackson Monk </dd>
<dd>
Blake Wagner </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td></td></tr>
    <tr><td class="paramname">newPCB</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Receives a new PCB and an existing queue. Checks if the queue is empty by checking if the head and tail pointers are null. If so the new PCB is the new head and tail. Checks the priortiy of the PCB received and itterates through the queue until we find processes with the same priority. Process that have the same priority are first in first out. The last PCB with the same priority now has its next pointer looking at the PCB we are inserting. The new PCB next now looks at the old next of the last PCB with the same priority. </p>

</div>
</div>
<a id="a63c16934c9d95f3583cf09891d18c095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c16934c9d95f3583cf09891d18c095">&#9670;&nbsp;</a></span>pcb_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcb.html">pcb</a>* pcb_allocate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a PCB. </p>
<dl class="section author"><dt>Author</dt><dd>Samesh Desai </dd>
<dd>
Noah Marner </dd>
<dd>
Jackson Monk </dd>
<dd>
Blake Wagner </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>PCB pointer</dd></dl>
<p>Uses sysallocmem function to allocate memeory for a pcb based on the size of the PCB struct. Then returns a pointer to the newly created PCB. If memory fails to allocate returns NULL and prints an error message. </p>

</div>
</div>
<a id="a32a28272eee57e85fc44b9045f0f0f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a28272eee57e85fc44b9045f0f0f6e">&#9670;&nbsp;</a></span>pcb_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcb.html">pcb</a>* pcb_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>susReady</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>susBlocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a name, returns a pointer to the PCB. </p>
<dl class="section author"><dt>Author</dt><dd>Blake Wagner </dd>
<dd>
Jackson Monk </dd>
<dd>
Noah Marner </dd>
<dd>
Samesh Desai </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ready</td><td></td></tr>
    <tr><td class="paramname">blocked</td><td></td></tr>
    <tr><td class="paramname">susReady</td><td></td></tr>
    <tr><td class="paramname">susBlocked</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Given a name, iterates through all the queues (ready, blocked, susReady, susBlocked) by creating a temp PCB pointer starting at the head of each queue. If a PCB has a name that matches the provided name immediatly returns the temp pointer which is pointing to that PCB. </p>

</div>
</div>
<a id="a1169eb5fd9b017a90dcbf1f29df686d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1169eb5fd9b017a90dcbf1f29df686d7">&#9670;&nbsp;</a></span>pcb_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcb_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcb.html">pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deallocates the memory associated with a PCB </p>
<dl class="section author"><dt>Author</dt><dd>Samesh Desai </dd>
<dd>
Noah Marner </dd>
<dd>
Blake Wagner </dd>
<dd>
Jackson Monk </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 or -1</dd></dl>
<p>Receives a PCB pointer and uses sysmemfree to deallocate the memory associated with the passed in PCB. If the memory freeing is sucessful, returns 1. If not returns -1 and prints and error message. </p>

</div>
</div>
<a id="af356fb7356e23ff1064529fb317d52eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af356fb7356e23ff1064529fb317d52eb">&#9670;&nbsp;</a></span>pcb_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcb_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>susReady</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>susBlocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcb.html">pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a PCB into the proper queue. </p>
<dl class="section author"><dt>Author</dt><dd>Noah Marner </dd>
<dd>
Jackson Monk </dd>
<dd>
Blake Wagner </dd>
<dd>
Samesh Desai </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ready</td><td></td></tr>
    <tr><td class="paramname">blocked</td><td></td></tr>
    <tr><td class="paramname">susReady</td><td></td></tr>
    <tr><td class="paramname">susBlocked</td><td></td></tr>
    <tr><td class="paramname">pcb</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Based on the state of the provided PCB calls enqueue with the provided PCB to add the PCB into either the ready, blocked, susReady, or susBlocked. Returns 0 for a successful insertion and -1 if failed. </p>

</div>
</div>
<a id="a688d95412aca3fe3fdfbe4018f71a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688d95412aca3fe3fdfbe4018f71a407">&#9670;&nbsp;</a></span>pcb_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcb_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>susReady</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>susBlocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcb.html">pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a PCB. </p>
<dl class="section author"><dt>Author</dt><dd>Noah Marner </dd>
<dd>
Jackson Monk </dd>
<dd>
Blake Wagner </dd>
<dd>
Samesh Desai </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ready</td><td></td></tr>
    <tr><td class="paramname">blocked</td><td></td></tr>
    <tr><td class="paramname">susReady</td><td></td></tr>
    <tr><td class="paramname">susBlocked</td><td></td></tr>
    <tr><td class="paramname">pcb</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Determines the queue the process is in based on the state of the passed in PCB. Creates a temp current PCB pointer. Iterates through the queue to find the PCB to remove. If PCB to remove is the head set head to point to next and return temp. Otherwise previous now pointer to current next. This circumvents the PCB we wish to remove. Lastly, check if the desired PCB is the tail and if so set the new tail to be the previous PCB since we are removing the tail. </p>

</div>
</div>
<a id="a90ca7260fdc87d4c04b5689c566fcea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ca7260fdc87d4c04b5689c566fcea0">&#9670;&nbsp;</a></span>pcb_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcb.html">pcb</a>* pcb_setup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new PCB. </p>
<dl class="section author"><dt>Author</dt><dd>Jackson Monk </dd>
<dd>
Blake Wagner </dd>
<dd>
Noah Marner </dd>
<dd>
Samesh Desai </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">clas</td><td></td></tr>
    <tr><td class="paramname">priority</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Takes in a char* for name, int for clas, and int for prioirty. Calls PCB allocate to create a new PCB, then assigns the passed in parameters to the data members of the PCB struct. When creating a new PCB, the defualt state is ready. Calls sysallocatemem for the name and state. Returns a pointer to the newly created PCB. </p>

</div>
</div>
<a id="ae8c35e290b62ef30ae01cebd25556715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c35e290b62ef30ae01cebd25556715">&#9670;&nbsp;</a></span>printq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue.html">queue</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of the queue. </p>
<dl class="section author"><dt>Author</dt><dd>Samesh Desai </dd>
<dd>
Noah Marner </dd>
<dd>
Jackson Monk </dd>
<dd>
Blake Wagner </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Given a queue, creates a temp PCB pointer to look at head, prints the contents of that PCB, looks at the current PCBs next, and prints the conents. The functions keeps iterating through the queue until next points to NULL. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
